name: Build and Deploy to AKS

on:
  push:
    branches: [ "main" ]

jobs:
  build:
    name: CI - Build & Test
    environment: dev
    runs-on: ubuntu-latest

    steps:
      - name: Obtener código fuente
        uses: actions/checkout@v4

      - name: Obtener SHA corto
        id: short
        run: echo "short_sha=$(git rev-parse --short $GITHUB_SHA)" >> $GITHUB_OUTPUT

      - name: Configurar .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Restaurar dependencias
        run: dotnet restore

      - name: Compilar proyecto
        run: dotnet build --no-restore

      - name: Ejecutar pruebas unitarias
        run: dotnet test --no-build --verbosity normal

      - name: Crear archivo ZIP del proyecto
        run: zip -r build-artifact.zip . -x "bin/*" "obj/*" ".git/*"

      - name: Subir artefacto ZIP
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: build-artifact.zip

      - name: Docker Login to ACR
        uses: docker/login-action@v3
        with:
          registry: acrappg5.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and Push Docker Image
        run: |
          IMAGE_NAME=acrappg5.azurecr.io/inventory-system-app
          TAG=${{ steps.short.outputs.short_sha }}
          echo "Construyendo imagen $IMAGE_NAME:$TAG"
          docker build --no-cache -t $IMAGE_NAME:$TAG -t $IMAGE_NAME:latest .
          docker push $IMAGE_NAME:$TAG
          docker push $IMAGE_NAME:latest

  deploy-dev:
    name: CD [dev]
    environment: dev
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Obtener SHA corto
        id: short
        run: echo "short_sha=$(git rev-parse --short $GITHUB_SHA)" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Establecer variables
        run: |
          IMAGE_NAME=acrappg5.azurecr.io/inventory-system-app
          TAG=${{ steps.short.outputs.short_sha }}
          AKS_NAME=aks-appg5-dev-west-01-AppG5
          RESOURCE_GROUP=rg-appg5-dev-west-01-AppG5

          echo "IMAGE=$IMAGE_NAME:$TAG" >> $GITHUB_ENV
          echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

      - name: Configurar kubectl
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME --overwrite-existing

      - name: Crear namespace si no existe
        run: |
          kubectl get namespace inventory-system || kubectl create namespace inventory-system

      - name: Crear Image Pull Secret para ACR
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=acrappg5.azurecr.io \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Actualizar imagen en deployment
        working-directory: k8s/base
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.IMAGE }}|g" deployment.yaml

      - name: Deploy a AKS usando Kustomize (base sin prefijo para DEV)
        run: |
          # Usar manifiestos base directamente para dev (sin namePrefix)
          # Los secrets vienen de Azure Key Vault automáticamente
          kubectl apply -k k8s/base

      - name: Esperar a que el deployment esté listo
        run: |
          kubectl rollout status deployment/inventory-system-app -n inventory-system --timeout=5m || {
            echo "=== DEPLOYMENT FAILED - DEBUG INFO ==="
            echo "--- Pod Status ---"
            kubectl get pods -n inventory-system -l app=inventory-system
            echo "--- Pod Describe ---"
            kubectl describe pods -n inventory-system -l app=inventory-system
            echo "--- Pod Logs ---"
            kubectl logs -n inventory-system -l app=inventory-system --tail=100 || true
            exit 1
          }

      - name: Obtener IP del servicio
        run: |
          echo "Esperando a que se asigne IP externa..."
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/inventory-system-service -n inventory-system --timeout=300s || true

          EXTERNAL_IP=$(kubectl get service inventory-system-service -n inventory-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          if [ -z "$EXTERNAL_IP" ]; then
            echo "No se pudo obtener la IP externa. Verifica el servicio:"
            kubectl get service inventory-system-service -n inventory-system
          else
            echo "Aplicación desplegada en: http://$EXTERNAL_IP"
          fi

  approval-qa:
    needs: [deploy-dev]
    environment:
      name: approval-qa
    runs-on: ubuntu-latest
    steps:
      - name: Aprobar
        run: echo "Esperando aprobación para QA"

  deploy-qa:
    name: CD [qa]
    environment: qa
    needs: approval-qa
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Obtener SHA corto
        id: short
        run: echo "short_sha=$(git rev-parse --short $GITHUB_SHA)" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Establecer variables
        run: |
          IMAGE_NAME=acrappg5.azurecr.io/inventory-system-app
          TAG=${{ steps.short.outputs.short_sha }}
          AKS_NAME=aks-appg5-qa-west-01-AppG5
          RESOURCE_GROUP=rg-appg5-qa-west-01-AppG5

          echo "IMAGE=$IMAGE_NAME:$TAG" >> $GITHUB_ENV
          echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

      - name: Configurar kubectl
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME --overwrite-existing

      - name: Crear namespace si no existe
        run: |
          kubectl get namespace inventory-system || kubectl create namespace inventory-system

      - name: Crear Image Pull Secret para ACR
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=acrappg5.azurecr.io \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Actualizar imagen en deployment
        working-directory: k8s/base
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.IMAGE }}|g" deployment.yaml

      - name: Deploy a AKS QA usando Kustomize Overlay
        run: |
          # Usar overlay de QA con namePrefix qa-
          # Los secrets vienen de Azure Key Vault automáticamente
          kubectl apply -k k8s/overlays/qa

      - name: Esperar a que el deployment esté listo
        run: |
          kubectl rollout status deployment/qa-inventory-system-app -n inventory-system --timeout=5m || {
            echo "=== DEPLOYMENT FAILED - DEBUG INFO ==="
            echo "--- Pod Status ---"
            kubectl get pods -n inventory-system -l app=inventory-system
            echo "--- Pod Describe ---"
            kubectl describe pods -n inventory-system -l app=inventory-system
            echo "--- Pod Logs ---"
            kubectl logs -n inventory-system -l app=inventory-system --tail=100 || true
            exit 1
          }

      - name: Obtener IP del servicio
        run: |
          echo "Esperando a que se asigne IP externa..."
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/qa-inventory-system-service -n inventory-system --timeout=300s || true

          EXTERNAL_IP=$(kubectl get service qa-inventory-system-service -n inventory-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          if [ -z "$EXTERNAL_IP" ]; then
            echo "No se pudo obtener la IP externa. Verifica el servicio:"
            kubectl get service qa-inventory-system-service -n inventory-system
          else
            echo "Aplicación QA desplegada en: http://$EXTERNAL_IP"
          fi

  approval-prd:
    needs: [deploy-qa]
    environment:
      name: approval-prd
    runs-on: ubuntu-latest
    steps:
      - name: Aprobar
        run: echo "Esperando aprobación para PRD"

  deploy-prd:
    name: CD [prd]
    environment: prd
    needs: approval-prd
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Obtener SHA corto
        id: short
        run: echo "short_sha=$(git rev-parse --short $GITHUB_SHA)" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Establecer variables
        run: |
          IMAGE_NAME=acrappg5.azurecr.io/inventory-system-app
          TAG=${{ steps.short.outputs.short_sha }}
          AKS_NAME=aks-appg5-prd-west-01-AppG5
          RESOURCE_GROUP=rg-appg5-prd-west-01-AppG5

          echo "IMAGE=$IMAGE_NAME:$TAG" >> $GITHUB_ENV
          echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

      - name: Configurar kubectl
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME --overwrite-existing

      - name: Crear namespace si no existe
        run: |
          kubectl get namespace inventory-system || kubectl create namespace inventory-system

      - name: Crear Image Pull Secret para ACR
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=acrappg5.azurecr.io \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Actualizar imagen en deployment
        working-directory: k8s/base
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.IMAGE }}|g" deployment.yaml

      - name: Deploy a AKS PRD usando Kustomize Overlay
        run: |
          # Usar overlay de PRD con namePrefix prd-
          # Los secrets vienen de Azure Key Vault automáticamente
          kubectl apply -k k8s/overlays/prd

      - name: Esperar a que el deployment esté listo
        run: |
          kubectl rollout status deployment/prd-inventory-system-app -n inventory-system --timeout=5m || {
            echo "=== DEPLOYMENT FAILED - DEBUG INFO ==="
            echo "--- Pod Status ---"
            kubectl get pods -n inventory-system -l app=inventory-system
            echo "--- Pod Describe ---"
            kubectl describe pods -n inventory-system -l app=inventory-system
            echo "--- Pod Logs ---"
            kubectl logs -n inventory-system -l app=inventory-system --tail=100 || true
            exit 1
          }

      - name: Obtener IP del servicio
        run: |
          echo "Esperando a que se asigne IP externa..."
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/prd-inventory-system-service -n inventory-system --timeout=300s || true

          EXTERNAL_IP=$(kubectl get service prd-inventory-system-service -n inventory-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          if [ -z "$EXTERNAL_IP" ]; then
            echo "No se pudo obtener la IP externa. Verifica el servicio:"
            kubectl get service prd-inventory-system-service -n inventory-system
          else
            echo "Aplicación PRD desplegada en: http://$EXTERNAL_IP"
          fi
