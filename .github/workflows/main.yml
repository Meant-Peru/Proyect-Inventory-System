name: Build and Deploy to AKS

on:
  push:
    branches: [ "main" ]

jobs:
  build:
    name: CI - Build & Test
    environment: dev
    runs-on: ubuntu-latest

    steps:
      - name: Obtener código fuente
        uses: actions/checkout@v4

      - name: Obtener SHA corto
        id: short
        run: echo "short_sha=$(git rev-parse --short $GITHUB_SHA)" >> $GITHUB_OUTPUT

      - name: Configurar .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Restaurar dependencias
        run: dotnet restore

      - name: Compilar proyecto
        run: dotnet build --no-restore

      - name: Ejecutar pruebas unitarias
        run: dotnet test --no-build --verbosity normal

      - name: Crear archivo ZIP del proyecto
        run: zip -r build-artifact.zip . -x "bin/*" "obj/*" ".git/*"

      - name: Subir artefacto ZIP
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: build-artifact.zip

      - name: Docker Login to ACR
        uses: docker/login-action@v3
        with:
          registry: acrappg5.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and Push Docker Image
        run: |
          IMAGE_NAME=acrappg5.azurecr.io/inventory-system-app
          TAG=${{ steps.short.outputs.short_sha }}
          echo "Construyendo imagen $IMAGE_NAME:$TAG"
          docker build -t $IMAGE_NAME:$TAG -t $IMAGE_NAME:latest .
          docker push $IMAGE_NAME:$TAG
          docker push $IMAGE_NAME:latest

  deploy-dev:
    name: CD [dev]
    environment: dev
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Obtener SHA corto
        id: short
        run: echo "short_sha=$(git rev-parse --short $GITHUB_SHA)" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Establecer variables
        run: |
          IMAGE_NAME=acrappg5.azurecr.io/inventory-system-app
          TAG=${{ steps.short.outputs.short_sha }}
          AKS_NAME=aks-appg5-dev-west-01-AppG5
          RESOURCE_GROUP=rg-appg5-dev-west-01-AppG5

          echo "IMAGE=$IMAGE_NAME:$TAG" >> $GITHUB_ENV
          echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

      - name: Configurar kubectl
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME --overwrite-existing

      - name: Crear namespace si no existe
        run: |
          kubectl get namespace inventory-system || kubectl create namespace inventory-system

      - name: Crear Image Pull Secret para ACR
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=acrappg5.azurecr.io \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Crear/Actualizar Secret de SQL Connection
        run: |
          kubectl create secret generic sql-connection-secret \
            --from-literal=connection-string="${{ vars.SQL_CONNECTION_STRING }}" \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Crear/Actualizar ConfigMap
        run: |
          kubectl create configmap inventory-config \
            --from-literal=ENV=dev \
            --from-literal=API_PROVIDER_URL="${{ vars.API_PROVIDER_URL }}" \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Actualizar imagen en deployment
        working-directory: k8s/base
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.IMAGE }}|g" deployment.yaml

      - name: Forzar eliminación de pods antiguos
        run: |
          # Eliminar deployment existente si hay problemas
          kubectl delete deployment inventory-system-app -n inventory-system --ignore-not-found=true --grace-period=0 --force || true
          sleep 5

      - name: Deploy a AKS usando Kustomize (sin prefijo)
        run: |
          # Usar manifiestos base directamente para dev (sin namePrefix)
          kubectl apply -k k8s/base

      - name: Esperar a que el deployment esté listo
        run: |
          kubectl rollout status deployment/inventory-system-app -n inventory-system --timeout=5m || {
            echo "=== DEPLOYMENT FAILED - DEBUG INFO ==="
            echo "--- Pod Status ---"
            kubectl get pods -n inventory-system -l app=inventory-system
            echo "--- Pod Describe ---"
            kubectl describe pods -n inventory-system -l app=inventory-system
            echo "--- Pod Logs ---"
            kubectl logs -n inventory-system -l app=inventory-system --tail=100 || true
            exit 1
          }

      - name: Obtener IP del servicio
        run: |
          echo "Esperando a que se asigne IP externa..."
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/inventory-system-service -n inventory-system --timeout=300s || true

          EXTERNAL_IP=$(kubectl get service inventory-system-service -n inventory-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          if [ -z "$EXTERNAL_IP" ]; then
            echo "No se pudo obtener la IP externa. Verifica el servicio:"
            kubectl get service inventory-system-service -n inventory-system
          else
            echo "Aplicación desplegada en: http://$EXTERNAL_IP"
          fi

  approval-qa:
    needs: [deploy-dev]
    environment:
      name: approval-qa
    runs-on: ubuntu-latest
    steps:
      - name: Aprobar
        run: echo "Esperando aprobación para QA"

  deploy-qa:
    name: CD [qa]
    environment: qa
    needs: approval-qa
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Obtener SHA corto
        id: short
        run: echo "short_sha=$(git rev-parse --short $GITHUB_SHA)" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Establecer variables
        run: |
          IMAGE_NAME=acrappg5.azurecr.io/inventory-system-app
          TAG=${{ steps.short.outputs.short_sha }}
          AKS_NAME=aks-appg5-qa-west-01-AppG5
          RESOURCE_GROUP=rg-appg5-qa-west-01-AppG5

          echo "IMAGE=$IMAGE_NAME:$TAG" >> $GITHUB_ENV
          echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

      - name: Configurar kubectl
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME --overwrite-existing

      - name: Crear namespace si no existe
        run: |
          kubectl get namespace inventory-system || kubectl create namespace inventory-system

      - name: Crear Image Pull Secret para ACR
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=acrappg5.azurecr.io \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Crear/Actualizar Secret de SQL Connection
        run: |
          kubectl create secret generic sql-connection-secret \
            --from-literal=connection-string="${{ vars.SQL_CONNECTION_STRING_QA }}" \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Crear/Actualizar ConfigMap
        run: |
          kubectl create configmap inventory-config \
            --from-literal=ENV=qa \
            --from-literal=API_PROVIDER_URL="${{ vars.API_PROVIDER_URL_QA }}" \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Actualizar imagen en deployment
        working-directory: k8s/base
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.IMAGE }}|g" deployment.yaml

      - name: Forzar eliminación de pods antiguos (QA)
        run: |
          kubectl delete deployment inventory-system-app -n inventory-system --ignore-not-found=true --grace-period=0 --force || true
          sleep 5

      - name: Deploy a AKS (QA)
        run: |
          kubectl apply -k k8s/base

      - name: Esperar a que el deployment esté listo
        run: |
          kubectl rollout status deployment/inventory-system-app -n inventory-system --timeout=5m || {
            echo "=== DEPLOYMENT FAILED - DEBUG INFO ==="
            echo "--- Pod Status ---"
            kubectl get pods -n inventory-system -l app=inventory-system
            echo "--- Pod Describe ---"
            kubectl describe pods -n inventory-system -l app=inventory-system
            echo "--- Pod Logs ---"
            kubectl logs -n inventory-system -l app=inventory-system --tail=100 || true
            exit 1
          }

      - name: Obtener IP del servicio
        run: |
          echo "Esperando a que se asigne IP externa..."
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/inventory-system-service -n inventory-system --timeout=300s || true

          EXTERNAL_IP=$(kubectl get service inventory-system-service -n inventory-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          if [ -z "$EXTERNAL_IP" ]; then
            echo "No se pudo obtener la IP externa. Verifica el servicio:"
            kubectl get service inventory-system-service -n inventory-system
          else
            echo "Aplicación QA desplegada en: http://$EXTERNAL_IP"
          fi

  approval-prd:
    needs: [deploy-qa]
    environment:
      name: approval-prd
    runs-on: ubuntu-latest
    steps:
      - name: Aprobar
        run: echo "Esperando aprobación para PRD"

  deploy-prd:
    name: CD [prd]
    environment: prd
    needs: approval-prd
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Obtener SHA corto
        id: short
        run: echo "short_sha=$(git rev-parse --short $GITHUB_SHA)" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Establecer variables
        run: |
          IMAGE_NAME=acrappg5.azurecr.io/inventory-system-app
          TAG=${{ steps.short.outputs.short_sha }}
          AKS_NAME=aks-appg5-prd-west-01-AppG5
          RESOURCE_GROUP=rg-appg5-prd-west-01-AppG5

          echo "IMAGE=$IMAGE_NAME:$TAG" >> $GITHUB_ENV
          echo "AKS_NAME=$AKS_NAME" >> $GITHUB_ENV
          echo "RESOURCE_GROUP=$RESOURCE_GROUP" >> $GITHUB_ENV

      - name: Configurar kubectl
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME --overwrite-existing

      - name: Crear namespace si no existe
        run: |
          kubectl get namespace inventory-system || kubectl create namespace inventory-system

      - name: Crear Image Pull Secret para ACR
        run: |
          kubectl create secret docker-registry acr-secret \
            --docker-server=acrappg5.azurecr.io \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Crear/Actualizar Secret de SQL Connection
        run: |
          kubectl create secret generic sql-connection-secret \
            --from-literal=connection-string="${{ vars.SQL_CONNECTION_STRING_PRD }}" \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Crear/Actualizar ConfigMap
        run: |
          kubectl create configmap inventory-config \
            --from-literal=ENV=prd \
            --from-literal=API_PROVIDER_URL="${{ vars.API_PROVIDER_URL_PRD }}" \
            --namespace=inventory-system \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Actualizar imagen en deployment
        working-directory: k8s/base
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.IMAGE }}|g" deployment.yaml

      - name: Forzar eliminación de pods antiguos (PRD)
        run: |
          kubectl delete deployment inventory-system-app -n inventory-system --ignore-not-found=true --grace-period=0 --force || true
          sleep 5

      - name: Deploy a AKS (PRD)
        run: |
          kubectl apply -k k8s/base

      - name: Esperar a que el deployment esté listo
        run: |
          kubectl rollout status deployment/inventory-system-app -n inventory-system --timeout=5m || {
            echo "=== DEPLOYMENT FAILED - DEBUG INFO ==="
            echo "--- Pod Status ---"
            kubectl get pods -n inventory-system -l app=inventory-system
            echo "--- Pod Describe ---"
            kubectl describe pods -n inventory-system -l app=inventory-system
            echo "--- Pod Logs ---"
            kubectl logs -n inventory-system -l app=inventory-system --tail=100 || true
            exit 1
          }

      - name: Obtener IP del servicio
        run: |
          echo "Esperando a que se asigne IP externa..."
          kubectl wait --for=jsonpath='{.status.loadBalancer.ingress}' \
            service/inventory-system-service -n inventory-system --timeout=300s || true

          EXTERNAL_IP=$(kubectl get service inventory-system-service -n inventory-system -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          if [ -z "$EXTERNAL_IP" ]; then
            echo "No se pudo obtener la IP externa. Verifica el servicio:"
            kubectl get service inventory-system-service -n inventory-system
          else
            echo "Aplicación PRD desplegada en: http://$EXTERNAL_IP"
          fi
